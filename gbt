#!/usr/bin/python3

# Git bulk toolkit

from argparse import ArgumentParser
from pathlib import Path
from subprocess import Popen, PIPE, check_output
from threading import Thread
from time import sleep
import os
import re
import shutil
import sys


class TerminalStyle:

    WHITE = "\033[97m"
    BLUE = "\033[94m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    DIM = "\033[2m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"
    CLEAR = "\033[0m"


class GitStatusWorker:

    def __init__(self, directory, worker_id):

        self._directory = directory
        self._worker_id = worker_id

        self._work_in_progress = False
        self._repo_id = ""
        self._branch = "unknown"
        self._location = "Up to date"
        self._modified_files = []
        self._untracked_files = []

        self._error_pulling = 0
        self._error_checking_out = 0
        self._error_getting_status = 0
        self._error_fetching = 0

    def status(self):

        if (self._work_in_progress is False):
            self._error_getting_status = 0
            self._work_in_progress = True
            self._thread = Thread(target=self._thread_method_status)
            self._thread.start()

    def fetch(self):

        if (self._work_in_progress is False):
            self._error_fetching = 0
            self._work_in_progress = True
            self._thread = Thread(target=self._thread_method_fetch)
            self._thread.start()

    def pull(self):

        if (self._work_in_progress is False):
            self._error_pulling = 0
            self._work_in_progress = True
            self._thread = Thread(target=self._thread_method_pull)
            self._thread.start()

    def checkout(self, branch_name):

        if (self._work_in_progress is False):
            self._error_checking_out = 0
            self._work_in_progress = True
            self._thread = Thread(target=self._thread_method_checkout, args=(branch_name,))
            self._thread.start()

    def short_name(self):

        return os.path.basename(os.path.normpath(self._directory))

    def branch(self):

        return self._branch

    def is_gbt_repo(self):

        return self._repo_id == "a5eab786a76c18fb765ae60742f970da2f5408fc"

    def location(self):

        return self._location[0].upper() + self._location[1:]

    def modified_files(self):

        return self._modified_files

    def untracked_files(self):

        return self._untracked_files

    def work_in_progress(self):

        return self._work_in_progress

    def error_pulling(self):

        return self._error_pulling

    def error_checking_out(self):

        return self._error_checking_out

    def error_getting_status(self):

        return self._error_getting_status

    def error_fetching(self):

        return self._error_fetching

    def error_occurred(self):

        return self.error_pulling() != 0 or self.error_checking_out() != 0 or self.error_getting_status() != 0 or self.error_fetching() != 0

    def join(self):

        self._thread.join()

    def _thread_method_status(self):

        self._modified_files.clear()
        self._untracked_files.clear()

        output = check_output(["git", "rev-list", "HEAD"], cwd=self._directory)
        output = output.decode("UTF-8")
        self._repo_id = output.split("\n")[-2]

        output = check_output(["git", "status", "-sb"], cwd=self._directory)
        output = output.decode("UTF-8")
        lines = output.split("\n")

        for line in lines:
            if (line.startswith("##")):
                line = line.replace("## ", "")
                if ("..." in line):
                    self._branch = line[:line.find("...")]
                else:
                    self._branch = line

                result = re.search("\[(.*)\]", line)
                if (result):
                    self._location = result.group(1)
            else:
                parts = line.split()

                if (len(parts) == 2):
                    indicator = parts[0]
                    filename = parts[1]

                    if ("M" in indicator):
                        self._modified_files.append(filename)

                    if ("??" in indicator):
                        self._untracked_files.append(filename)

        self._work_in_progress = False

    def _thread_method_fetch(self):

        process = Popen(["git", "fetch"], stdout=PIPE, stderr=PIPE, cwd=self._directory)
        process.communicate()

        self._error_fetching = process.returncode
        self._work_in_progress = False

    def _thread_method_checkout(self, branch_name):

        process = Popen(["git", "checkout", branch_name], stdout=PIPE, stderr=PIPE, cwd=self._directory)
        process.communicate()

        self._error_checking_out = process.returncode
        self._work_in_progress = False

    def _thread_method_pull(self):

        process = Popen(["git", "pull"], stdout=PIPE, stderr=PIPE, cwd=self._directory)
        process.communicate()

        self._error_pulling = process.returncode
        self._work_in_progress = False


def get_subdirectories(parent_directory):

    return [os.path.join(parent_directory, name) for name in os.listdir(parent_directory) if os.path.isdir(os.path.join(parent_directory, name))]


def read_first_line(filename):

    if (os.path.isfile(filename) is False):
        return None

    with open(filename, 'r') as f:
        return f.readline()


def write_first_line(filename, line):
    with open(filename, 'w') as f:
        return f.writelines([line])


def display_progress(action_text, action_error_method):

    while (True):

        complete_success_count = 0
        complete_fail_count = 0
        incomplete_count = 0

        progress_bar = TerminalStyle.GREEN

        for worker in git_workers:
            if (worker.work_in_progress() is False):
                get_error_method = getattr(worker, action_error_method)
                if (get_error_method() == 0):
                    progress_bar += "✔"
                    complete_success_count += 1
                else:
                    progress_bar += TerminalStyle.RED + "✕" + TerminalStyle.GREEN
                    complete_fail_count += 1
            else:
                progress_bar += " "
                incomplete_count += 1

        progress_line = "\r[" + progress_bar.ljust(len(git_workers)) + TerminalStyle.CLEAR + "] " + action_text + " (" + str(complete_success_count + complete_fail_count) + " / " + str(incomplete_count + complete_success_count + complete_fail_count) + ") "

        sys.stdout.write(progress_line)

        if (incomplete_count is 0):
            sys.stdout.write("\r\n")
            sys.stdout.flush()
            break

    for worker in git_workers:
        worker.join()


def pull_all(git_workers):

    for worker in git_workers:
        worker.pull()

    display_progress("Pulling", "error_pulling")


def checkout_all(git_workers, branch_name):

    for worker in git_workers:
        worker.checkout(branch_name)

    display_progress("Checking out " + branch_name, "error_checking_out")


def fetch_all(git_workers):

    for worker in git_workers:
        worker.fetch()

    display_progress("Fetching", "error_fetching")


def status_all(git_workers):

    for worker in git_workers:
        worker.status()

    display_progress("Getting status", "error_getting_status")


def get_development_dir():

    config_file = str(Path.home()) + "/.config/gbt.conf"
    development_dir = read_first_line(config_file)

    if (development_dir is None):
        show_help()

    while (development_dir is None):
        if (development_dir is None):
            provided_directory = input("Development directory not set.\nProvide the directory under which your git repositories reside: [" + os.getcwd() + "]:")
            if (provided_directory == ""):
                development_dir = os.getcwd()
            else:
                if (os.path.isdir(provided_directory)):
                    development_dir = provided_directory
                else:
                    print("Directory does not exist")

    write_first_line(config_file, development_dir)

    return development_dir


def print_results(git_workers):

    longest_subdirectory_name = 0
    longest_branch_name = 0
    longest_location = 0

    for worker in git_workers:
        if (len(worker.short_name()) > longest_subdirectory_name):
            longest_subdirectory_name = len(worker.short_name())

        if (len(worker.branch()) > longest_branch_name):
            longest_branch_name = len(worker.branch())

        if (len(worker.location()) > longest_location):
            longest_location = len(worker.location())

    horizontal_line()

    output_lines = []
    work_to_do = False
    gbt_has_update = False

    for worker in git_workers:

        if (worker.error_occurred()):
            status_string = TerminalStyle.RED + worker.short_name().ljust(longest_subdirectory_name + longest_branch_name + longest_location + 10)
            status_string += "Error(s): "

            if (worker.error_fetching() != 0):
                status_string += "Fetching (" + str(worker.error_fetching()) + ")"

            if (worker.error_pulling() != 0):
                status_string += "Pulling (" + str(worker.error_pulling()) + ")"

            if (worker.error_checking_out() != 0):
                status_string += "Checking out branch (" + str(worker.error_checking_out()) + ")"

            status_string += TerminalStyle.CLEAR

            print(status_string)

        else:
            name_string = worker.short_name().ljust(longest_subdirectory_name)

            location_string = ""

            if ("behind" in worker.location().lower()):

                gbt_has_update = worker.is_gbt_repo()

                if (len(worker.modified_files()) + len(worker.untracked_files()) > 0):
                    location_string += TerminalStyle.RED
                else:
                    location_string += TerminalStyle.YELLOW

                location_string += worker.location().rjust(longest_location)
                work_to_do = True

            elif ("ahead" in worker.location().lower()):
                location_string += TerminalStyle.GREEN + worker.location().rjust(longest_location)
                work_to_do = True

            else:
                location_string += worker.location().rjust(longest_location)

            location_string += TerminalStyle.CLEAR

            branch_string = worker.branch().ljust(longest_branch_name)

            if (worker.branch() != "master"):
                branch_string = TerminalStyle.WHITE + worker.branch().ljust(longest_branch_name) + TerminalStyle.CLEAR

            status_string = ""

            if (len(worker.modified_files()) + len(worker.untracked_files()) == 0):
                status_string += TerminalStyle.BLUE + "Nothing to commit" + TerminalStyle.CLEAR

            else:
                work_to_do = True
                status_string += TerminalStyle.YELLOW
                status_string += str(len(worker.modified_files()) + len(worker.untracked_files())) + " file(s) modified/untracked"
                status_string += TerminalStyle.CLEAR

            print(name_string +
                  TerminalStyle.DIM + " [ " + TerminalStyle.CLEAR +
                  location_string +
                  TerminalStyle.DIM + " on " + TerminalStyle.CLEAR +
                  branch_string +
                  TerminalStyle.DIM + " ] " + TerminalStyle.CLEAR +
                  status_string)

    horizontal_line()

    return work_to_do, gbt_has_update


def horizontal_line():

    term_columns, term_lines = shutil.get_terminal_size((80, 20))
    print(TerminalStyle.DIM + "─" * term_columns + TerminalStyle.CLEAR)


def create_workers():

    subdirectories = get_subdirectories(development_dir)
    subdirectories.sort()

    git_workers = []
    worker_id = 1

    for subdirectory in subdirectories:
        git_dir = os.path.join(subdirectory, ".git/")
        if (os.path.isdir(git_dir)):
            git_workers.append(GitStatusWorker(subdirectory, worker_id))
            worker_id += 1

    return git_workers


def show_help():
    print("Git Bulk Toolkit (gbt) usage:")
    print("\tgbt [fetch] [pull] [status] [checkout <branch_name>]")
    print("")
    print("Examples:")
    print("\tgbt status")
    print("\tShow status for all repositories under development directory")
    print("")
    print("\tgbt fetch status")
    print("\tRun 'git fetch' on all repositories under development directory, and show status")
    print("")
    print("\tgbt pull")
    print("\tRun 'git pull' on all repositories under development directory")
    print("")
    print("\tgbt checkout master")
    print("\tRun 'git checkout master' on all repositories under development directory")
    print("")


# Start program

args = sys.argv[1:]

fetch = ("fetch" in args)
pull = ("pull" in args)
status = ("status" in args)
checkout = ("checkout" in args)
help = ("help" in args or "--help" in args)
branch_name = None

if (help):
    show_help()
    exit(0)

if (pull and fetch):
    print("fetch and pull are incompatible")
    exit(1)

if (checkout and (pull or fetch or status)):
    print("checkout is not compatible with other commands")
    exit(1)

if (checkout):
    if (len(args) == 2):
        branch_name = args[1]
    else:
        print("checkout requires a branch name")
        exit(1)

# Set the defaults

if ((fetch or pull or status or checkout) is False):
    fetch = True
    status = True

# Get the configured development directory, or ask for it

development_dir = get_development_dir()
print("Working on [ " + development_dir + " ]")

# Do the work

git_workers = create_workers()

if (checkout):
    checkout_all(git_workers, branch_name)

else:
    if (pull):
        pull_all(git_workers)

    elif (fetch):
        fetch_all(git_workers)

    if (status):
        status_all(git_workers)
        work_to_do, gbt_has_update = print_results(git_workers)

        if (work_to_do is False):
            print(TerminalStyle.GREEN + "Everything up to date" + TerminalStyle.CLEAR)

        if (gbt_has_update is True):
            print(TerminalStyle.GREEN + "Update available for gbt" + TerminalStyle.CLEAR)
